% The introduction should explain the principal motivation for the project and show how the work fits into the broad area of surrounding computer science and give a brief survey of previous related work. It should generally be unnecessary to quote at length from technical papers or textbooks. If a simple bibliographic reference is insufficient, consign any lengthy quotation to an appendix.

Blockchains promise to decentralise applications that were traditionally run in a centralised manner. The implications of this are far-reaching: central banks can be replaced by decentralised cryptocurrencies~\cite{nakamotoBitcoinPeertoPeerElectronic2008,perniceCryptocurrency2021}, traditional corporations can be replaced with decentralised autonomous organisations (DAOs)~\cite{hassanDecentralizedAutonomousOrganization2021,ethereumWhite}, internet infrastructure like DNS servers can be decentralised~\cite{EthereumNameService}, and any possible algorithm can be run on a decentralised `world computer'~\cite{ethereumWhite,ethereumYellow}. The innovation that makes blockchains possible is the byzantine consensus algorithm.

Byzantine fault-tolerant consensus algorithms allow a group of parties to agree on some piece of information under adverse conditions where some messages can be lost and some parties are controlled by a malicious adversary. For example, one could create a cryptocurrency by using such an algorithm to reach consensus on a ledger of transactions like ``Account Alice transfers account Bob Â£10''; the algorithm will ensure that transactions cannot be lost and the system cannot be sabotaged by malicious actors.

Byzantine consensus algorithms can be viewed as solutions to the byzantine generals problem~\cite{lamportByzantineGeneralsProblem1982}, in which malicious actors are represented by byzantine generals. Here, a group of generals must all agree to siege a castle at the same time, but they can only communicate via messengers that take some time to arrive and can be captured en route. Additionally, up to a third of the generals may be malicious, and try to prevent the other generals from reaching consensus on a time to attack. By following a byzantine consensus protocol the generals can reach consensus on a value like ``attack at dawn''. Multi-valued consensus algorithms allow consensus to be reached on multiple values, resulting in a continuously growing log that can never be modified or erased, only extended. This problem statement assumes that the number of participating generals is fixed.

Blockchains can be either permissioned, or permissionless. Permissioned blockchains have a previously agreed set of participants in the consensus algorithm, whereas permissionless blockchains allow participants to join and leave freely. Most well-known blockchains, such as Bitcoin~\cite{nakamotoBitcoinPeertoPeerElectronic2008} and Ethereum~\cite{ethereumWhite, ethereumYellow}, are of the permissionless variety. Permissioned blockchains can be deployed in a permissionless setting if they are augmented with an additional layer of security, which can be proof of work, proof of stake, or some other similar mechanism. These aim to prevent a `Sybil attack' where a large number of malicious nodes join the network, exceeding the threshold that only one-third of nodes can be malicious. For example, proof of work adds a requirement for proof of computational work to participate in consensus, making Sybil attacks economically and computationally infeasible. Permissioned blockchains are of interest for applications within a group or organisation, such as a company, where the participating nodes are known in advance.

HotStuff is a byzantine consensus algorithm that was notably used by Meta's Libra project~\cite{baudetStateMachineReplication2019}, a cancelled permissioned blockchain-based payments system. The algorithm is relevant because of various performance advantages over other byzantine consensus algorithms such as PBFT~\cite{castroPracticalByzantineFault1999}, SBFT~\cite{golanguetaSBFTScalableDecentralized2019}, DLS~\cite{dworkConsensusPresencePartial1988}, Tendermint~\cite{kwonTendermintConsensusMining2014}, and Casper~\cite{buterinCasperFriendlyFinality2019}.

Building practical, well-performing implementations of consensus algorithms is non-trivial. These algorithms are usually given in short pieces of pseudocode that may not be specified precisely and require much more code to implement in practice. Such software has a wide range of failure modes mostly due to their parallel nature, including deadlocks, resource starvation, and bugs in the implementation~\cite{chandraPaxosMadeLive2007}.

The main contributions of this dissertation are:
\begin{itemize}
	\item Giving a complete specification and proof of HotStuff (Section~\ref{spec}), that adapts the pacemaker mechanism, which was not specified in the original paper. This specification synthesises the chained algorithm described in the paper (Section~\ref{chaining}), a view-change protocol based on other talks and papers (Section~\ref{viewchange}), and my changes to integrate the pacemaker with HotStuff without the need for synchronised clocks.
	\item Providing a reference implementation of HotStuff in OCaml based on a paper by Yin et. ~al~~\cite{yinHotStuffBFTConsensus2019}.
	\item Giving solutions to key practical challenges of implementation and optimisations that can be made (Section~\ref{performance}), as well as showing their effectiveness (Section~\ref{ablation}).
	\item Synthesising information from different sources to provide a complete explanation of the HotStuff algorithm, and how it can be arrived at through modifications to simpler consensus algorithms (basic algorithm Section~\ref{hotstufftheory}, chained algorithm Section~\ref{chaining}, pacemaker Section~\ref{pacemaker}).
\end{itemize}