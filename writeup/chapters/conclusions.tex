% This chapter is likely to be very short and it may well refer back to the Introduction. It might offer a reflection on the lessons learned and explain how you would have planned the project if starting again with the benefit of hindsight.

% general-use framework ??
\section{Future Work}
Further work would port to using the async library which is known to have better performance. It was out of scope to rewrite in async or use it in the first place due to poor documentation (although now I could look at the type signatures and understand the documentation). Hopefully reimplementing would give better performance and avoid the bugs of capnrpc. I would carry out more extensive tests on the message sending capabilities before diving into implementation. I would be more aware beforehand of the whole algorithm (including the pacemaker code) and implement based on the new pseudocode we have presented and proven correct. This would allow for better structuring of the code.

% if i was to reimplement i would already have a solid grasp on the algorithm, language, and frameworks. i could focus more on the practicalities of bottlenecks, profiling, testing lwt & queueing, benchmarking, etc. from the outset

% to develop a real production ready system that has a reasonable level of performance would take an order of magnitude more time than this problem. one would have to carefully study byzantine threats and how one would counter availability attacks. In some cases optimisations may be antagonistic with security considerations (eg. TCP style truncation could be attacked). if the system was to be deployed in a real environment (eg. a cryptocurrency) security would be paramount, and it could take years of fixes and bug bounties to develop a robust system.

We have presented a potential path for implementing verifiable anonymous identities and reconfiguration using our permissioned blockchain, future work could consist of a practical implementation of this.